import 'dart:io';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:flutter/material.dart' as material;
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import '../models/note.dart';
import '../themes/app_themes.dart';

/// Service for generating beautiful, colorful PDFs from notes
class PdfGeneratorService {
  /// Generate a colorful PDF from a note
  Future<File> generateNotePdf(Note note, {bool includeMetadata = true}) async {
    final pdf = pw.Document();
    
    // Convert note card color from hex
    final noteColor = AppThemes.hexToColor(note.color);
    final pdfColor = PdfColor(
      noteColor.r / 255,
      noteColor.g / 255,
      noteColor.b / 255,
    );

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(40),
        build: (context) => [
          // Header with note color accent
          pw.Container(
            decoration: pw.BoxDecoration(
              border: pw.Border(
                left: pw.BorderSide(
                  color: pdfColor,
                  width: 5,
                ),
              ),
            ),
            padding: const pw.EdgeInsets.only(left: 15, bottom: 10),
            child: pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                // Title
                pw.Text(
                  note.title.isEmpty ? 'Untitled' : note.title,
                  style: pw.TextStyle(
                    fontSize: 28,
                    fontWeight: pw.FontWeight.bold,
                    color: pdfColor,
                  ),
                ),
                
                // Metadata
                if (includeMetadata) ...[
                  pw.SizedBox(height: 10),
                  pw.Text(
                    'Created: ${DateFormat('MMM dd, yyyy - hh:mm a').format(note.createdAt)}',
                    style: const pw.TextStyle(
                      fontSize: 10,
                      color: PdfColors.grey700,
                    ),
                  ),
                  if (note.updatedAt != note.createdAt)
                    pw.Text(
                      'Updated: ${DateFormat('MMM dd, yyyy - hh:mm a').format(note.updatedAt)}',
                      style: const pw.TextStyle(
                        fontSize: 10,
                        color: PdfColors.grey700,
                      ),
                    ),
                  if (note.tags.isNotEmpty)
                    pw.Padding(
                      padding: const pw.EdgeInsets.only(top: 5),
                      child: pw.Wrap(
                        spacing: 5,
                        children: note.tags.map((tag) {
                          return pw.Container(
                            padding: const pw.EdgeInsets.symmetric(
                              horizontal: 8,
                              vertical: 3,
                            ),
                            decoration: pw.BoxDecoration(
                              color: pdfColor.flatten(),
                              borderRadius: pw.BorderRadius.circular(10),
                            ),
                            child: pw.Text(
                              tag,
                              style: const pw.TextStyle(
                                fontSize: 9,
                                color: PdfColors.white,
                              ),
                            ),
                          );
                        }).toList(),
                      ),
                    ),
                ],
              ],
            ),
          ),

          pw.SizedBox(height: 20),

          // Content with formatting
          _buildFormattedContent(note),

          // Footer
          pw.SizedBox(height: 30),
          pw.Divider(color: pdfColor),
          pw.SizedBox(height: 10),
          pw.Row(
            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
            children: [
              pw.Text(
                'Generated by Flutter Notes App',
                style: pw.TextStyle(
                  fontSize: 8,
                  color: PdfColors.grey600,
                  fontStyle: pw.FontStyle.italic,
                ),
              ),
              pw.Text(
                DateFormat('MMM dd, yyyy').format(DateTime.now()),
                style: const pw.TextStyle(
                  fontSize: 8,
                  color: PdfColors.grey600,
                ),
              ),
            ],
          ),
        ],
      ),
    );

    // Save PDF
    final output = await _getOutputFile(note.title);
    await output.writeAsBytes(await pdf.save());
    return output;
  }

  /// Build formatted content with colors and styles
  pw.Widget _buildFormattedContent(Note note) {
    if (note.formatting == null || note.formatting!.segments.isEmpty) {
      // Plain text
      return pw.Text(
        note.content,
        style: const pw.TextStyle(
          fontSize: 12,
          lineSpacing: 1.5,
        ),
      );
    }

    // Rich text with formatting
    final List<pw.InlineSpan> spans = [];
    int currentIndex = 0;
    
    final sortedSegments = List.from(note.formatting!.segments)
      ..sort((a, b) => a.start.compareTo(b.start));

    for (var segment in sortedSegments) {
      // Add plain text before segment
      if (segment.start > currentIndex) {
        spans.add(
          pw.TextSpan(
            text: note.content.substring(currentIndex, segment.start),
            style: const pw.TextStyle(fontSize: 12),
          ),
        );
      }

      // Add formatted segment with color
      final segmentStyle = pw.TextStyle(
        fontSize: segment.style.fontSize ?? 12,
        fontWeight: segment.style.fontWeight == material.FontWeight.bold
            ? pw.FontWeight.bold
            : pw.FontWeight.normal,
        fontStyle: segment.style.fontStyle == material.FontStyle.italic
            ? pw.FontStyle.italic
            : pw.FontStyle.normal,
        decoration: segment.style.decoration == material.TextDecoration.underline
            ? pw.TextDecoration.underline
            : segment.style.decoration == material.TextDecoration.lineThrough
                ? pw.TextDecoration.lineThrough
                : null,
        color: segment.style.color != null
            ? PdfColor.fromInt(segment.style.color!.value)
            : PdfColors.black,
        background: segment.style.backgroundColor != null
            ? pw.BoxDecoration(
                color: PdfColor.fromInt(segment.style.backgroundColor!.value),
              )
            : null,
      );

      spans.add(
        pw.TextSpan(
          text: segment.text,
          style: segmentStyle,
        ),
      );

      currentIndex = segment.end;
    }

    // Add remaining plain text
    if (currentIndex < note.content.length) {
      spans.add(
        pw.TextSpan(
          text: note.content.substring(currentIndex),
          style: const pw.TextStyle(fontSize: 12),
        ),
      );
    }

    return pw.RichText(
      text: pw.TextSpan(
        children: spans,
        style: const pw.TextStyle(
          fontSize: 12,
          lineSpacing: 1.5,
        ),
      ),
    );
  }

  /// Generate PDF for multiple notes
  Future<File> generateMultiNotePdf(
    List<Note> notes, {
    bool includeMetadata = true,
    String fileName = 'Notes Export',
  }) async {
    final pdf = pw.Document();

    for (var i = 0; i < notes.length; i++) {
      final note = notes[i];
      final noteColor = AppThemes.hexToColor(note.color);
      final pdfColor = PdfColor(
        noteColor.r / 255,
        noteColor.g / 255,
        noteColor.b / 255,
      );

      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(40),
          build: (context) => [
            // Page number
            pw.Align(
              alignment: pw.Alignment.topRight,
              child: pw.Text(
                'Note ${i + 1} of ${notes.length}',
                style: const pw.TextStyle(
                  fontSize: 9,
                  color: PdfColors.grey600,
                ),
              ),
            ),
            pw.SizedBox(height: 10),

            // Note content
            pw.Container(
              decoration: pw.BoxDecoration(
                border: pw.Border(
                  left: pw.BorderSide(color: pdfColor, width: 5),
                ),
              ),
              padding: const pw.EdgeInsets.only(left: 15),
              child: pw.Column(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Text(
                    note.title.isEmpty ? 'Untitled' : note.title,
                    style: pw.TextStyle(
                      fontSize: 24,
                      fontWeight: pw.FontWeight.bold,
                      color: pdfColor,
                    ),
                  ),
                  if (includeMetadata) ...[
                    pw.SizedBox(height: 5),
                    pw.Text(
                      DateFormat('MMM dd, yyyy').format(note.createdAt),
                      style: const pw.TextStyle(
                        fontSize: 9,
                        color: PdfColors.grey700,
                      ),
                    ),
                  ],
                  pw.SizedBox(height: 15),
                  _buildFormattedContent(note),
                ],
              ),
            ),
          ],
        ),
      );
    }

    final output = await _getOutputFile(fileName);
    await output.writeAsBytes(await pdf.save());
    return output;
  }

  /// Get output file path
  Future<File> _getOutputFile(String baseName) async {
    final directory = await getTemporaryDirectory();
    final fileName = '${_sanitizeFileName(baseName)}_${DateTime.now().millisecondsSinceEpoch}.pdf';
    return File('${directory.path}/$fileName');
  }

  /// Sanitize filename
  String _sanitizeFileName(String name) {
    return name
        .replaceAll(RegExp(r'[^\w\s-]'), '')
        .replaceAll(RegExp(r'\s+'), '_')
        .substring(0, name.length > 50 ? 50 : name.length);
  }
}
